#include "kernel/private.h"

// main.c

// Use our alternate data sections.
gword _More0 gZEROED; // not .bss
gword _More1 gZEROED = 0x9998; // not .data
gword _Final __attribute__ ((section (".final"))) = 0x9990;
gword _Final_Startup __attribute__ ((section (".final.startup"))) = 0x9991;

// Hardware Reference -- Thanks, Tim!
//     https://tlindner.macmess.org/?page_id=767

// pia_reset_sequence table traced from coco3 startup.
struct pia_reset_sequence {
    gword addr;
    gbyte value;
} pia_reset_sequence[] gSETUP_DATA = {
    { 0xff21, 0x00 },  // choose data direction
    { 0xff23, 0x00 },  // choose data direction
    { 0xff20, 0xfe },  // bit 0 input; rest are outputs.
    { 0xff22, 0xfa },  // bit 1 and bits 3-7 are outputs.
    { 0xff21, 0x34 },
    { 0xff23, 0x34 },
    { 0xff22, 0x00 },  // output all 0s on Pia1 PortB
    { 0xff20, 0x02 },
    { 0xff01, 0x00 },  // choose data direction
    { 0xff03, 0x00 },  // choose data direction
    { 0xff00, 0x00 },  // inputs
    { 0xff02, 0xff },  // outputs
    { 0xff01, 0x34 },
    { 0xff03, 0x34 },
    { 0 }
};


// gime_reset_sequence table traced from coco3 startup.
struct gime_reset_sequence {
    gword addr;
    gbyte value;
} gime_reset_sequence[] gSETUP_DATA = {
// Generated by copico-bonobo/v2.4/firmware/c$ py gime_init_gen.py 
  { 0xff90, 0xcc },
  { 0xff91, 0x00 },
  { 0xff92, 0x00 },
  { 0xff93, 0x00 },
  { 0xff94, 0xff },
  { 0xff95, 0xff },
  { 0xff96, 0x00 },
  { 0xff97, 0x00 },
  { 0xff98, 0x00 },
  { 0xff99, 0x00 },
  { 0xff9a, 0x00 },
  { 0xff9b, 0x00 },
  { 0xff9c, 0x0f },
  { 0xff9d, 0xe0 },
  { 0xff9e, 0x00 },
  { 0xff9f, 0x00 },
  { 0xffa0, 0x38 },
  { 0xffa1, 0x39 },
  { 0xffa2, 0x3a },
  { 0xffa3, 0x3b },
  { 0xffa4, 0x3c },
  { 0xffa5, 0x3d },
  { 0xffa6, 0x3e },
  { 0xffa7, 0x3f },
  { 0xffa8, 0x38 },
  { 0xffa9, 0x30 },
  { 0xffaa, 0x31 },
  { 0xffab, 0x32 },
  { 0xffac, 0x33 },
  { 0xffad, 0x3d },
  { 0xffae, 0x35 },
  { 0xffaf, 0x3f },
  { 0xffb0, 0x12 },
  { 0xffb1, 0x24 },
  { 0xffb2, 0x0b },
  { 0xffb3, 0x07 },
  { 0xffb4, 0x3f },
  { 0xffb5, 0x1f },
  { 0xffb6, 0x09 },
  { 0xffb7, 0x26 },
  { 0xffb8, 0x00 },
  { 0xffb9, 0x12 },
  { 0xffba, 0x00 },
  { 0xffbb, 0x3f },
  { 0xffbc, 0x00 },
  { 0xffbd, 0x12 },
  { 0xffbe, 0x00 },
  { 0xffbf, 0x26 },
  { 0 }
};

void Delay(gword n) {
    for (gword i = 0; i < n; i++) {
        asm volatile(" mul \n mul \n mul \n mul \n mul" : : : "d");
    }
}

void ColdPrint(const char* s) {
    // PutStr("\xF5 ");
    PutStr("*** ");
    PutStr(s);  
    PutChar('\n');

    // Assuming PIA0 is already set up for keyboard scanning:
    gPoke1(KEYBOARD_PROBE, ~(1<<4)); // Probe for Down Arrow
    gbyte sense = ((1<<3) & ~gPeek1(KEYBOARD_SENSE));
    if (sense) {
        Delay(15000);
    } else {
        Delay(1000);
    }
}

#if 0
void SamInit() {
    // ram_sizer marks the extra SAM bit that sets our ram size.
    gword ram_sizer = 0;

    // SAM has a setting for 4K, 16K, or 64K.
    // Probe for keys 0 (4K) and 1 (64K).  Default is 16K.
    gPoke1(KEYBOARD_PROBE, ~1); // probe for '0'
    gbyte zero_key = ~(0x10 & gPeek1(KEYBOARD_SENSE)); // sense for '0'

    gPoke1(KEYBOARD_PROBE, ~2); // probe for '0'
    gbyte one_key = ~(0x10 & gPeek1(KEYBOARD_SENSE)); // sense for '1'

    if (zero_key) {
        // M=00 for 4K
        ram_sizer = 0;  // No extra bit.
    } else if (one_key) {
        // M=10 for 64K
        ram_sizer = 0xFFDC;
    } else {
        // M=01 for 16K
        ram_sizer = 0xFFDA;
    }

    // For p the even numbers in the magic SAM range:
    for (gword p = 0xFFC0; p < 0xFFE0; p+=2) {
        // FFD[EF] should be FFDF for "TY=1" for "all ram, no rom".
        gbyte yes = (p == 0xFFDE || p == ram_sizer); 
        gPoke1(p+yes, 0);
    }
}
#endif

void entry_wrapper() {
    asm volatile("\n"
        "  .globl entry \n"
        "entry:         \n"
        "  orcc #$50    \n"  // No IRQs, FIRQs, for now.
        "  lds #$01FE   \n"  // Reset the stack
        "  jmp _main    \n"
        );
}

extern void embark(void);

gword PinDownGlobalNames[] gSETUP_DATA = {
    // Taking the address of `embark` prevents it from being
    // inlined inside main.  Only things inlined inside main
    // are in the area called `.text.startup` which gets
    // recycled after setup, when we embark.
    (gword) embark,

    // Taking the address of other things in the kernel
    // prevents them from being optimized away.
    // Things that might be referenced by games
    // need to exist in the compiled kernel!
    (gword) Breakkey_Handler,
    (gword) Irq_Handler,
    (gword) Irq_Handler_entry,
    (gword) Irq_Handler_Wrapper,
    (gword) Network_Handler,
    (gword) gAlloc64,
    (gword) gFree64,
    (gword) Reset64,
    (gword) gSendCast,
    (gword) gReceiveCast64,

    (gword) gTextScreen,
    (gword) gPMode1Screen,
    (gword) gModeScreen,
    (gword) xAfterSetup,
    (gword) xSendControlPacket,
    (gword) gNetworkLog,
    (gword) gFatal,
    (gword) PutStr,
    (gword) PutChar,

    (gword) memset,
    (gword) memcpy,
    (gword) memset_words,
    (gword) memcpy_words,
    (gword) strlen,

    (gword) entry_wrapper,
    (gword) &_More0,
    (gword) &_More1,
    (gword) &_Final,
    (gword) &_Final_Startup,
    (gword) &gScore,
    (gword) &gReal,
    (gword) &gWall,
    (gword) &gConfig,
};

void PlaceOpcodeJMP(gword at, gfunc to) {
    gPoke1(at+0, OPCODE_JMP_Extended);
    gPoke2(at+1, to);
}

// Interrupt Relays
gword coco2_relays[] gSETUP_DATA = {
    0x0100,
    0x0103,
    0x010F,
    0x010C,
    0x0106,
    0x0109,
};
gword coco3_relays[] gSETUP_DATA = {
    0xFEEE,
    0xFEF1,
    0xFEF4,
    0xFEF7,
    0xFEFA,
    0xFEFD,
};
gfunc handlers[] gSETUP_DATA = {
    gFatalSWI3,
    gFatalSWI2,
    gFatalFIRQ,
    Irq_Handler_entry,
    gFatalSWI1,
    gFatalNMI,
};

char StrNekotOS[] gSETUP_DATA = "NEKOTOS ... ";
char StrReady[] gSETUP_DATA = " READY";

void SplashRestore(int x, int y) {
    if (x < 0) return;
    if (y < 0) return;
    if (x >= 32) return;
    if (y >= 16) return;
    gPoke1(Cons + 32*y + x, gPeek1(0x200 + 32*y + x));
}

void SplashSet(int x, int y) {
    if (x < 0) return;
    if (y < 0) return;
    if (x >= 32) return;
    if (y >= 16) return;
    gPoke1(Cons + 32*y + x, 0xFF);
}

void Splash() {
    memcpy_words(0x0200, 0x0400, 256);

        for (int i = 0; i < 16; i++) {
            for (int x = 16 - i; x < 16 + i; x++) {
                int y1 = 8 - i;
                int y2 = 8 + i;
                SplashSet(x, y1);
                SplashSet(x, y2);
            }
            for (int y = 8 - i; y < 8 + i; y++) {
                int x1 = 16 - i;
                int x2 = 16 + i;
                SplashSet(x1, y);
                SplashSet(x2, y);
            }
            Delay(100);

            for (int x = 16 - i; x < 16 + i; x++) {
                int y1 = 8 - i;
                int y2 = 8 + i;
                SplashRestore(x, y1);
                SplashRestore(x, y2);
            }
            for (int y = 8 - i; y < 8 + i; y++) {
                int x1 = 16 - i;
                int x2 = 16 + i;
                SplashRestore(x1, y);
                SplashRestore(x2, y);
            }
        }
}

void setup(void) {
    memset_words(0x0000, 0, 0x40); // .bss
    for (struct pia_reset_sequence *p = pia_reset_sequence; p->addr; p++) {
        gPoke1(p->addr, p->value);
    }
    gPoke1(0xFF90, 0x88);
    gPoke1(0xFF91, 0x00);

    //Delay(10000);
    // Sam Pre-Init to TEXT AT 0x0400 for Cold Boot
#if 1
    for (gword p = 0xFFC0; p < 0xFFD4; p+=2) {
        gbyte yes = (p == 0xFFC8);
        gPoke1(p+yes, 0);
    }
#endif
    //Delay(10000);
    Splash();

    Console_Init();
    ColdPrint("INIT");

#if 0
    Vdg_Init();
    ColdPrint("VDG");
#endif

    // --------- BEGIN COLD SCREEN --------

    //memset_words(0x0000, 0x3020, 0x40);   // Initial Spoonfed Screen
    //memset_words(0x0080, 0xF3F3, 16);
    //memset_words(0x00A0, 0x2D2D, 32);
    //memset_words(0x00E0, 0xFCFC, 16);
    // memset_words(0x0200, 0x3320, 0x100);  // Eventual NekotOS Console.
    // memset_words(0x0400, 0x3420, 0x80);  // ROM boot screen.
    // Delay(10000);
    ColdPrint(StrNekotOS);

    // Redirect the 6 Interrupt Relays to our handlers.
    for (gbyte i = 0; i < 6; i++) {
        PlaceOpcodeJMP(coco2_relays[i], handlers[i]);
        PlaceOpcodeJMP(coco3_relays[i], handlers[i]);
    }
    ColdPrint("VECT");

    // Coco2 16K, CocoIO:         Works with D5 or D5.
    // Coco3 (6309/512K) CocoIO:  Works with D4 or D5.

    // Coco2 16K, Bonobo:         Works with D5 or D5.
    // Coco3 (6309/512K) Bonobo:  Works with D4 or D5.

    // D4 chooses "lower 32K" for $0000-$7FFF.
    // D5 chooses "upper 32K" for $0000-$7FFF.
    if (0) { // D5?
        gPoke1(0xFFD5, 0);
        ColdPrint("D5");
    } else {
        gPoke1(0xFFD4, 0);
        ColdPrint("D4");
    }

    gPoke1(0xFFD6, 0);  // slow CPU speed.
    ColdPrint("D6");
    gPoke1(0xFFD8, 0);
    ColdPrint("D8");

    // DA and DC are for memory size.
    gPoke1(0xFFDB, 0);
    ColdPrint("DB");
    gPoke1(0xFFDC, 0);
    ColdPrint("DC");

    gPoke1(0xFFDF, 0);
    ColdPrint("DF");  // all RAM

    for (struct gime_reset_sequence *p = gime_reset_sequence; p->addr; p++) {
        gPoke1(p->addr, p->value);
    }
    ColdPrint("GIME");
    // Coco3 in Compatibility Mode.
    gPoke1(0xFF90, 0x88);
    gPoke1(0xFF91, 0x00);
    ColdPrint("COMPAT");

    // memset_words(0x0200, 0, 0x80); // vdg console p1
    // memset_words(0x0300, 0, 0x80); // vdg console p2
    ColdPrint("ZERO");

    // The post-linker puts Version Hash at $0118.
    // Copy Version Hash down to page 0, at $0018.
    memcpy((void*)0x0018, (void*)0x0118, 8);
    ColdPrint("HASH");

    Kern_Init();
    ColdPrint("KERN");

    Vdg_Init();
    ColdPrint("VDG");

    // --------- END COLD SCREEN --------
    // X Console_Init();
    // X Vdg_Init();

    ColdPrint(StrNekotOS);

    // memset_words(0x0400, 0, 0x80); // chunks of 64-gbyte
    // Alloc64_Init();  // first 4 chunks in 0x04XX.

    Spin_Init();
    Network_Init();
    HelloMCP();

    // gPeek1(KEYBOARD_PROBE);  // Clear VSYNC IRQ // TODO
    gPoke1(0xFF03, 0x35);    // +1: Enable VSYNC (FS) IRQ

    ColdPrint(StrReady);
    Delay(3000);
}

void embark(void) {
    // Wipe out the setup/startup code, to prove it is never needed again.
    memset_words( (gword)&_Final, 0x3F3F, ((gword)&_Final_Startup - (gword)&_Final)>>1);

    StartTask((gword)ChatTask); // Start the no-game task.
}

int main() {
    gPin(entry_wrapper);
    gPin(PinDownGlobalNames);

    setup();
    embark();

    // NOT REACHED
    gFatal("MAIN", 0);
}
